# Data Structure / Algorithm

#  자료구조
-- 대부분 주기억장치에서 이루어질 내용

>* 자료를 효율적으로 이용할 수 있는 방법론 
>* 데이터를 구조적으로 표현하는 방식
>* DB에서 얼마나 효율적으로, 필요한 것만 가져 올 것인가. 

- **컴퓨터의 자원은 한정적이기 때문에 효율적으로 사용하는 것이 중요하다.**

###  생김새에 따라:
>	- 원시구조: 정수, 실수, 문자 ...
>	- 선형구조: 배열, 연결 리스트, 스택, 큐, 덱
>	- 비선형구조: 트리, 그래프

###  실체화에 따라:
>	- 물리적 구조:
>		- 정수, 실수, 문자 
>		- 배열, 연결 리스트
>			* 배열: 같은 성질, 카데고리, 클래스를 묶어 정리해 놓은 것들. 구조/크기가 정해져 있기 때문에 추가,삭제,수정이 어렵다. 배열의 크기를 정해놓고, 몇번째를 찾아오라고 하면 n*#  주소로 찾아간다. 쉽게 빠르게 찾아 올 수 있다. 
>			* 연결리스트: 하나씩 떨어진 리스트, 끈으로 연결 해 놓듯, 리스트 끝에 다음 객체에 대한 정보를 담고 있어야 함. 순차적으로만 찾아가야하고, 공간을 비효율 적으로 사용한다. 하지만 삽입, 삭제, 수정이 쉽다. 객체에 대한 사이즈가 정해져있지 않다. (속도와 공간효율 low)
>	- 추상적 구조:
>		- 스택, 큐, 덱, 트리, 그래프
>			* stack: 쌓아놓고 마지막 것부터 소비. push & pop ㅣLIFO
>			* queue: put -> out 선입선출 FIFO
>			* dequeue: stack+queue: 앞뒤로 넣고 빼고
>			* tree: 부모와 상하관계, 노드
>			* graph: 

#  알고리즘
>* 알고리즘이란?...
>- 문제해결을 위한 절차/방법
>- 어떠한 문제를 해결하기 위한 여러 동작들의 모음
>
>* 선택정렬: O(n^2), min부터 먼자 찾아 정렬 
>* 버블정렬: O(n^2), 두개를 계속해서 비교, 도치
>* 삽입: O(n^2) 두개 사이에 올 값을 찾아 삽입하며 정렬
>* 병합: merge sort O(n log n) 그룹지어 비교하며 정렬
>* 퀵정렬: O(n log n) 그룹을 나눠 기준을 잡고 정렬
>* 시간복잡도: big O
>
>* 선형탐색: O(n) found in a list. Go thourh each item to find one. 
>* 이진탐색 (binary search): Starting from a head, each node has two branches. 
